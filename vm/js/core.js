// A JavaScript wrapper for a uFork WASM core.

// This module exports a 'make_core' constructor function that takes an object
// with the following properties:

//  wasm_url
//      The URL of the uFork WASM binary, as a string. Required.

//  on_wakeup(sender, events)

//      A function that is called whenever a device completes an asynchronous
//      transaction, indicating that execution of the core can resume from its
//      idle state. The 'sender' is a device or proxy capability and 'events'
//      is the array of event pointers generated by the transaction. Optional.

//  on_log(log_level, ...values)
//      A function that is called with any values logged by the core.
//      The 'values' may or may not be strings. Optional.

//  on_txn(ep, kp_or_fx)

//      A function that is called at the conclusion of each actor transaction
//      and device pseudo-transaction. Keep in mind that actor transactions can
//      be aborted and thus have no effect.

//      The 'ep' parameter is a pointer to the current event.

//      If the target of 'ep' is a device or proxy actor,
//      'kp_or_fx' is a pointer to the event generated by the transaction.
//      Otherwise 'kp_or_fx' is a pointer to the current continuation.

//      Optional.

//  on_audit(code, evidence, ep, kp)
//      A function that is called when a non-fatal error (such as an aborted
//      transaction) occurs. Optional.

//      The 'code' is an error fixnum such as E_ABORT.
//      The 'evidence' is a value associated with the error, such as the reason
//      provided to the 'end abort' instruction.
//      The 'ep' points to the current event.
//      The 'kp' points to the current continuation, if there is one.

//  log_level
//      An integer controlling the core's logging verbosity. Each level includes
//      all levels before it.

//      ufork.LOG_NONE (0)
//          No logging.
//      ufork.LOG_INFO (1)
//          Low volume, always shown unless all logging is disabled.
//      ufork.LOG_WARN (2)
//          Something went wrong, but perhaps it wasn't fatal.
//      ufork.LOG_DEBUG (3)
//          More detail to narrow down the source of a problem.
//      ufork.LOG_TRACE (4)
//          Extremely detailed (for example, all reserve and release actions).

//      The default level is LOG_WARN.

//  import_map
//      An object that maps prefixes to base URLs, used to resolve imports.
//      For example, the import map

//          {"lib/": "https://ufork.org/lib/"}

//      would resolve "lib/std.asm" to "https://ufork.org/lib/std.asm".

//  compilers
//      An object that maps file extensions to compiler functions.

//      Compilers are used by the 'h_import' method to transform text, fetched
//      over the network, to uFork IR. A compiler has the signature:

//          compile(text, src) -> ir

//      where 'text' is the source text as a string, 'src' is the module's
//      source (usually a URL, optional), and 'ir' is a CRLF object as
//      described in ir.md, unless compilation failed, in which case 'ir'
//      should have a non-empty array as its "errors" property.

//      For example, if both assembly and Scheme modules were to be imported,
//      the compilers object might look like:

//          {
//              asm: compile_assembly,
//              scm: compile_scheme
//          }

// The returned object is an uninitialized core, containing a bunch of methods.
// The methods beginning with "u_" are reentrant, but the methods beginning
// with "h_" are non-reentrant.

// To initialize the core, call the 'h_initialize' method and run the returned
// requestor to completion.

/*jslint web, global, bitwise */

import ufork from "./ufork.js";
import assemble from "https://ufork.org/lib/assemble.js";
import parseq from "https://ufork.org/lib/parseq.js";
import requestorize from "https://ufork.org/lib/rq/requestorize.js";
import unpromise from "https://ufork.org/lib/rq/unpromise.js";
const lib_url = import.meta.resolve("https://ufork.org/lib/");
const wasm_url = import.meta.resolve("https://ufork.org/wasm/ufork.debug.wasm");
const asm_url = import.meta.resolve("../../lib/eq.asm");

const {
    cap_to_ptr,
    current_continuation,
    fault_msg,
    fix_to_i32,
    fixnum,
    in_mem,
    is_cap,
    is_ptr,
    is_ram,
    is_raw,
    is_rom,
    print,
    print_quad,
    ptr_to_cap,
    ramptr,
    rawofs,
    read_quad,
    romptr,
    write_quad,
    crlf_literals,
    crlf_types,
    imm_labels,
    op_labels,
    UNDEF_RAW,
    NIL_RAW,
    TYPE_T,
    ACTOR_T,
    PROXY_T,
    STUB_T,
    INSTR_T,
    PAIR_T,
    DICT_T,
    VM_DICT,
    VM_JUMP,
    VM_DUP,
    VM_ALU,
    VM_CMP,
    VM_IF,
    VM_ACTOR,
    VM_END,
    VM_SPONSOR,
    VM_DEQUE,
    QUAD_ROM_MAX,
    QUAD_RAM_MAX,
    MEMORY_OFS,
    DEBUG_DEV_OFS,
    SPONSOR_OFS
} = ufork;

function make_core({
    wasm_url,
    on_wakeup,
    on_log,
    on_txn,
    on_audit,
    log_level = ufork.LOG_WARN,
    import_map = {},
    compilers = {}
}) {
    let wasm_exports;
    let boot_caps_dict = []; // empty
    let wasm_caps = Object.create(null);
    let on_dispose_callbacks = [];
    let import_promises = Object.create(null);
    let module_texts = Object.create(null);
    let rom_debugs = Object.create(null);
    let wasm_call_in_progress = false;
    let deferred_queue = [];
    let initial_rom_ofs;
    let initial_ram_ofs;
    let entry_ptr;

// The presence of a particular logging method indicates that its associated log
// level is enabled. Thus calling code can log conditionally, avoiding the
// performance overhead of producing diagnostics that would just be discarded
// anyway.

    function make_log_method(log_level) {
        if (on_log !== undefined) {
            return function (...values) {
                on_log(log_level, ...values);
            };
        }
    }

    const u_info = (
        log_level >= ufork.LOG_INFO
        ? make_log_method(ufork.LOG_INFO)
        : undefined
    );
    const u_warn = (
        log_level >= ufork.LOG_WARN
        ? make_log_method(ufork.LOG_WARN)
        : undefined
    );
    const u_debug = (
        log_level >= ufork.LOG_DEBUG
        ? make_log_method(ufork.LOG_DEBUG)
        : undefined
    );
    const u_trace = (
        log_level >= ufork.LOG_TRACE
        ? make_log_method(ufork.LOG_TRACE)
        : undefined
    );

    function u_audit(code, evidence, ep, kp) {
        if (typeof on_audit === "function") {
            on_audit(code, evidence, ep, kp);
        }
    }

    function wrap_wasm_call(get_wasm_function) {
        return function (...args) {

// It is only valid to call 'u_defer' during a non-reentrant call into WASM.
// There is no need to implement a mutex here because Rust's RefCell will panic
// upon illegal reentry.

            wasm_call_in_progress = true;
            let result = get_wasm_function()(...args);
            wasm_call_in_progress = false;

// Some callbacks that make non-reentrant calls may have been scheduled
// by 'u_defer' whilst the WASM component had control. Run them now and flush
// the queue.

            const callbacks = deferred_queue;
            deferred_queue = [];
            callbacks.forEach((callback) => callback());
            if (Number.isSafeInteger(result)) {

// Some of the WASM exports return a fixnum, but fixnums appear to be negative
// because the top bit is set. Discard the sign.

                result = result >>> 0;  // i32 -> u32
            }
            return result;
        };
    }

    //const h_init = wrap_wasm_call(() => wasm_exports.h_init);
    const h_run_loop = wrap_wasm_call(() => wasm_exports.h_run_loop);
    const h_step = wrap_wasm_call(() => wasm_exports.h_step);
    const h_event_enqueue = wrap_wasm_call(() => wasm_exports.h_event_enqueue);
    const h_revert = wrap_wasm_call(() => wasm_exports.h_revert);
    const h_gc_run = wrap_wasm_call(() => wasm_exports.h_gc_run);
    const h_rom_buffer = wrap_wasm_call(() => wasm_exports.h_rom_buffer);
    const h_rom_top = wrap_wasm_call(() => wasm_exports.h_rom_top);
    const h_set_rom_top = wrap_wasm_call(() => wasm_exports.h_set_rom_top);
    const h_reserve_rom = wrap_wasm_call(() => wasm_exports.h_reserve_rom);
    const h_ram_buffer = wrap_wasm_call(() => wasm_exports.h_ram_buffer);
    const h_ram_top = wrap_wasm_call(() => wasm_exports.h_ram_top);
    const h_reserve = wrap_wasm_call(() => wasm_exports.h_reserve);
    const h_reserve_stub = wrap_wasm_call(() => wasm_exports.h_reserve_stub);
    const h_release_stub = wrap_wasm_call(() => wasm_exports.h_release_stub);
    const h_car = wrap_wasm_call(() => wasm_exports.h_car);
    const h_cdr = wrap_wasm_call(() => wasm_exports.h_cdr);
    const h_gc_color = wrap_wasm_call(() => wasm_exports.h_gc_color);
    const h_gc_state = wrap_wasm_call(() => wasm_exports.h_gc_state);

    function u_memory() {

// WARNING! The WASM memory buffer can move if it is resized. We get a fresh
// pointer each time for safety.

        return wasm_exports.memory.buffer;
    }

// WASM mandates little-endian byte ordering.

    function h_rom() {
        const mem_base = u_memory();
        const rom_ofs = h_rom_buffer();
        const rom_len = rawofs(h_rom_top()) << 4;
        return new Uint8Array(mem_base, rom_ofs, rom_len); // not copied
    }

    function h_ram() {
        const mem_base = u_memory();
        const ram_ofs = h_ram_buffer();
        const ram_len = rawofs(h_ram_top()) << 4;
        return new Uint8Array(mem_base, ram_ofs, ram_len); // not copied
    }

// We avoid unnecessary reentrancy by caching the offsets at initialization
// time. Even if the WASM memory is rearranged, offsets should not change. We
// can not, however, avoid reentrancy if we wish to check the current top of
// ROM or RAM.

    function u_rom_ofs() {
        return initial_rom_ofs;
    }

    function u_ram_ofs() {
        return initial_ram_ofs;
    }

    function u_rom() {
        const mem_base = u_memory();
        const rom_ofs = u_rom_ofs();
        const rom_len = QUAD_ROM_MAX << 4;
        return new Uint8Array(mem_base, rom_ofs, rom_len); // not copied
    }

    function u_ram() {
        const mem_base = u_memory();
        const ram_ofs = u_ram_ofs();
        const ram_len = QUAD_RAM_MAX << 4;
        return new Uint8Array(mem_base, ram_ofs, ram_len); // not copied
    }

    function u_rom_debugs() {
        return Object.assign(Object.create(null), rom_debugs);
    }

    function u_module_texts() {
        return Object.assign(Object.create(null), module_texts);
    }

    function u_cap_to_ptr(cap) {
        const ptr = cap_to_ptr(cap);
        if (ptr === UNDEF_RAW) {
            if (u_warn !== undefined) {
                u_warn("cap_to_ptr: must be mutable", print(cap));
            }
            return UNDEF_RAW;
        }
        return ptr;
    }

    function u_ptr_to_cap(ptr) {
        const cap = ptr_to_cap(ptr);
        if (cap === UNDEF_RAW) {
            if (u_warn !== undefined) {
                u_warn("ptr_to_cap: must be mutable", print(ptr));
            }
            return UNDEF_RAW;
        }
        return cap;
    }

    function u_mem_pages() {
        return u_memory().byteLength / 65536;
    }

    function u_read_quad(ptr) {
        if (is_ram(ptr)) {
            const ram_ofs = rawofs(ptr);
            if (ram_ofs < QUAD_RAM_MAX) {
                return read_quad(u_ram(), ram_ofs);
            }
            if (u_warn !== undefined) {
                u_warn("u_read_quad: RAM ptr out of bounds", print(ptr));
            }
        } else if (is_rom(ptr)) {
            const rom_ofs = rawofs(ptr);
            if (rom_ofs < QUAD_ROM_MAX) {
                return read_quad(u_rom(), rom_ofs);
            }
            if (u_warn !== undefined) {
                u_warn("u_read_quad: ROM ptr out of bounds", print(ptr));
            }
        } else if (u_warn !== undefined) {
            u_warn("u_read_quad: required ptr, got", print(ptr));
        }
    }

    function u_write_quad(ptr, quad) {
        if (is_ram(ptr)) {
            const ram_ofs = rawofs(ptr);
            if (ram_ofs < QUAD_RAM_MAX) {
                write_quad(u_ram(), ram_ofs, quad);
            } else if (u_warn !== undefined) {
                u_warn("u_write_quad: RAM ptr out of bounds", print(ptr));
            }
        } else if (is_rom(ptr)) {
            const rom_ofs = rawofs(ptr);
            if (rom_ofs < QUAD_ROM_MAX) {
                write_quad(u_rom(), rom_ofs, quad);
            } else if (u_warn !== undefined) {
                u_warn("u_write_quad: ROM ptr out of bounds", print(ptr));
            }
        } else if (u_warn !== undefined) {
            u_warn("u_write_quad: required ptr, got", print(ptr));
        }
    }

    function u_current_continuation() {
        return current_continuation(u_ram());
    }

    function u_nth(list_ptr, n) {

// Safely extract the 'nth' item from a list of pairs.

//           0          -1          -2          -3
//      lst -->[car,cdr]-->[car,cdr]-->[car,cdr]-->...
//            +1 |        +2 |        +3 |
//               V           V           V

        if (n === 0) {
            return list_ptr;
        }
        if (!is_ptr(list_ptr)) {
            return UNDEF_RAW;
        }
        const pair = u_read_quad(list_ptr);
        if (pair.t !== PAIR_T) {
            return UNDEF_RAW;
        }
        if (n === 1) {
            return pair.x;
        }
        return (
            n < 0
            ? u_nth(pair.y, n + 1)
            : u_nth(pair.y, n - 1)
        );
    }

    function u_next(ptr) {
        if (is_ptr(ptr)) {
            const quad = u_read_quad(ptr);
            const t = quad.t;
            if (t === INSTR_T) {
                const op = quad.x;
                if ((op !== VM_IF) && (op !== VM_JUMP) && (op !== VM_END)) {
                    return quad.z;
                }
            } else if (t === PAIR_T) {
                return quad.y;
            } else {
                return quad.z;
            }
        }
        return UNDEF_RAW;
    }

    function u_defer(callback) {

// Schedule a callback to be run at the conclusion of the currently running
// non-reentrant method, for example 'h_run_loop'. The callback can safely call
// the core's non-reentrant methods.

        if (!wasm_call_in_progress) {
            throw new Error("u_defer called outside of WASM control.");
        }
        deferred_queue.push(callback);
    }

    function h_reserve_ram(quad = {}) {
        const ptr = h_reserve();
        u_write_quad(ptr, quad);
        return ptr;
    }

    function h_rom_alloc(debug_info) {
        const ptr = h_reserve_rom();
        rom_debugs[ptr] = debug_info;
        return ptr;
    }

    function h_load(ir, imports) {

// Load a module into ROM. At this point its imports have already been loaded.

        let definitions = Object.create(null);
        let type_checks = [];
        let cyclic_data_checks = [];
        let arity_checks = [];

        function fail(message, ...data) {
            throw new Error(
                message + ": " + data.map(function (the_data) {
                    return JSON.stringify(the_data, undefined, 4);
                }).join(" ")
            );
        }

        function definition_raw(name) {
            return (
                definitions[name] !== undefined
                ? definitions[name]
                : fail("Not defined", name)
            );
        }

        function lookup(ref) {
            return (
                ref.module === undefined
                ? definition_raw(ref.name)
                : (
                    imports[ref.module] !== undefined
                    ? (
                        is_raw(imports[ref.module][ref.name])
                        ? imports[ref.module][ref.name]
                        : fail("Not exported", ref.module + "." + ref.name, ref)
                    )
                    : fail("Not imported", ref.module, ref)
                )
            );
        }

        function label(name, labels, offset = 0) {
            const index = labels.findIndex(function (label) {
                return label === name;
            });
            return (
                (Number.isSafeInteger(index) && index >= 0)
                ? fixnum(index + offset)
                : fail("Bad label", name)
            );
        }

        function kind(node) {
            return (
                Number.isSafeInteger(node)
                ? "fixnum"
                : node.kind
            );
        }

        function literal(node) {
            const raw = crlf_literals[node.value];
            return (
                is_raw(raw)
                ? raw
                : fail("Not a literal", node)
            );
        }

        function fix(node) {
            return (
                kind(node) === "fixnum"
                ? fixnum(node) // FIXME: check integer bounds?
                : fail("Not a fixnum", node)
            );
        }

        function value(node) {
            const the_kind = kind(node);
            if (the_kind === "literal") {
                return literal(node);
            }
            if (the_kind === "fixnum") {
                return fix(node);
            }
            if (the_kind === "ref") {
                return lookup(node);
            }
            if (
                the_kind === "pair"
                || the_kind === "dict"
                || the_kind === "quad"
                || the_kind === "instr"
            ) {
                return populate(h_rom_alloc(node.debug), node);
            }
            if (the_kind === "type") {
                const raw = crlf_types[node.name];
                return (
                    is_raw(raw)
                    ? raw
                    : (
                        Number.isSafeInteger(node.arity)
                        ? populate(h_rom_alloc(node.debug), node)
                        : lookup(node)
                    )
                );
            }
            return fail("Not a value", node);
        }

        function instruction(node) {
            const raw = value(node);
            type_checks.push({
                raw,
                t: INSTR_T,
                node,
                msg: "Expected an instruction"
            });
            return raw;
        }

        function populate(ptr, node) {
            const the_kind = kind(node);
            let quad = {};
            if (the_kind === "type") {
                quad.t = TYPE_T;
                quad.x = fix(node.arity);
            } else if (the_kind === "pair") {
                quad.t = PAIR_T;
                quad.x = value(node.head);
                quad.y = value(node.tail);
                if (
                    node.tail.kind === "ref"
                    && node.tail.module === undefined
                ) {
                    cyclic_data_checks.push([quad.y, PAIR_T, "y", node.tail]);
                }
            } else if (the_kind === "dict") {
                quad.t = DICT_T;
                quad.x = value(node.key);
                quad.y = value(node.value);
                quad.z = value(node.next); // dict/nil
                if (quad.z !== NIL_RAW) {
                    type_checks.push({
                        raw: quad.z,
                        t: DICT_T,
                        node: node.next,
                        msg: "Expected a dict"
                    });
                }
                if (
                    node.next.kind === "ref"
                    && node.next.module === undefined
                ) {
                    cyclic_data_checks.push([quad.z, DICT_T, "z", node.next]);
                }
            } else if (the_kind === "quad") {
                quad.t = value(node.t);
                let arity = 0;
                if (node.x !== undefined) {
                    quad.x = value(node.x);
                    arity = 1;
                }
                if (node.y !== undefined) {
                    quad.y = value(node.y);
                    arity = 2;
                }
                if (node.z !== undefined) {
                    quad.z = value(node.z);
                    arity = 3;
                }
                arity_checks.push([quad.t, arity, node.t]);
            } else if (the_kind === "instr") {
                quad.t = INSTR_T;
                quad.x = label(node.op, op_labels);
                if (node.op === "typeq") {
                    const imm_raw = value(node.imm);
                    type_checks.push({
                        raw: imm_raw,
                        t: TYPE_T,
                        node: node.imm,
                        msg: "Expected a type"
                    });
                    quad.y = imm_raw;
                    quad.z = instruction(node.k);
                } else if (
                    node.op === "quad"
                    || node.op === "pair"
                    || node.op === "part"
                    || node.op === "nth"
                    || node.op === "drop"
                    || node.op === "pick"
                    || node.op === "dup"
                    || node.op === "roll"
                    || node.op === "msg"
                    || node.op === "state"
                ) {
                    quad.y = fix(node.imm);
                    quad.z = instruction(node.k);
                } else if (
                    node.op === "eq"
                    || node.op === "push"
                    || node.op === "assert"
                ) {
                    quad.y = value(node.imm);
                    quad.z = instruction(node.k);
                } else if (node.op === "debug") {
                    quad.z = instruction(node.k);
                } else if (node.op === "if") {
                    quad.y = instruction(node.t);
                    quad.z = instruction(node.f);
                } else if (node.op === "dict") {
                    quad.y = label(node.imm, imm_labels[VM_DICT]);
                    quad.z = instruction(node.k);
                } else if (node.op === "deque") {
                    quad.y = label(node.imm, imm_labels[VM_DEQUE]);
                    quad.z = instruction(node.k);
                } else if (node.op === "alu") {
                    quad.y = label(node.imm, imm_labels[VM_ALU]);
                    quad.z = instruction(node.k);
                } else if (node.op === "cmp") {
                    quad.y = label(node.imm, imm_labels[VM_CMP]);
                    quad.z = instruction(node.k);
                } else if (node.op === "actor") {
                    quad.y = label(node.imm, imm_labels[VM_ACTOR]);
                    quad.z = instruction(node.k);
                } else if (node.op === "end") {
                    quad.y = label(node.imm, imm_labels[VM_END], -1);
                } else if (node.op === "sponsor") {
                    quad.y = label(node.imm, imm_labels[VM_SPONSOR]);
                    quad.z = instruction(node.k);
                } else if (node.op !== "jump") {

// The 'jump' instruction has no fields.

                    return fail("Not an op", node);
                }
            } else {
                return fail("Not a quad", node);
            }
            u_write_quad(ptr, quad);
            return ptr;
        }

        function is_quad(node) {
            return (
                kind(node) === "pair"
                || kind(node) === "dict"
                || kind(node) === "quad"
                || kind(node) === "instr"
            );
        }

// Allocate a placeholder quad for each definition that requires one, or set the
// raw directly. Only resolve refs that refer to imports, not definitions.

        Object.entries(ir.ast.define).forEach(function ([name, node]) {
            if (is_quad(node)) {
                definitions[name] = h_rom_alloc(node.debug);
            } else if (kind(node) === "ref") {
                if (node.module !== undefined) {
                    definitions[name] = lookup(node);
                }
            } else {
                definitions[name] = value(node);
            }
        });

// Now we resolve any refs that refer to definitions. This is tricky because
// they could be cyclic. If they are not cyclic, we resolve them in order of
// dependency.

        let ref_deps = Object.create(null);
        Object.entries(ir.ast.define).forEach(function ([name, node]) {
            if (kind(node) === "ref" && node.module === undefined) {
                ref_deps[name] = node.name;
            }
        });

        function ref_depth(name, seen = []) {
            const dep_name = ref_deps[name];
            if (seen.includes(name)) {
                return fail("Cyclic refs", ir.ast.define[name]);
            }
            return (
                ref_deps[dep_name] === undefined
                ? 0
                : 1 + ref_depth(dep_name, seen.concat(name))
            );
        }

        Object.keys(ref_deps).sort(function (a, b) {
            return ref_depth(a) - ref_depth(b);
        }).forEach(function (name) {
            definitions[name] = lookup(ir.ast.define[name]);
        });

// Populate each placeholder quad.

        Object.entries(ir.ast.define).forEach(function ([name, node]) {
            if (is_quad(node)) {
                populate(definitions[name], node);
            }
        });

// Check the type of dubious quads now they are fully populated.

        type_checks.forEach(function ({raw, t, node, msg}) {
            if (!is_ptr(raw) || u_read_quad(raw).t !== t) {
                return fail(msg, node);
            }
        });

// Check for cyclic data structures, which are pathological for some
// instructions.

        cyclic_data_checks.forEach(function ([raw, t, k_field, node]) {
            let seen = [];
            while (is_ptr(raw)) {
                if (seen.includes(raw)) {
                    return fail("Cyclic", node);
                }
                const quad = u_read_quad(raw);
                if (quad.t !== t) {
                    break;
                }
                seen.push(raw);
                raw = quad[k_field];
            }
        });

// Check that custom quad have a valid type in the T field, and an arity
// matching the type.

        arity_checks.forEach(function ([type_raw, arity, node]) {
            if (
                !in_mem(type_raw)
                && type_raw !== TYPE_T
                && type_raw !== INSTR_T
                && type_raw !== PAIR_T
                && type_raw !== DICT_T
            ) {
                return fail("Not a type", node);
            }
            const type_quad = u_read_quad(type_raw);
            if (type_quad.t !== TYPE_T) {
                return fail("Not a type", node);
            }
            if (arity !== fix_to_i32(type_quad.x)) {
                return fail("Wrong arity for type", node);
            }
        });

// Populate the exports object.

        let exports_object = Object.create(null);
        ir.ast.export.forEach(function (name) {
            exports_object[name] = definition_raw(name);
        });
        return exports_object;
    }

    function u_map_src(src) {
        if (src !== undefined) {
            const alias = Object.keys(import_map).find(function (key) {
                return src.startsWith(key);
            });
            if (alias !== undefined) {
                return src.replace(alias, import_map[alias]);
            }
        }
    }

    function h_import_promise(src, content) {

        function compile(text) {
            const extension = src.split(".").pop();
            if (!Object.hasOwn(compilers, extension)) {
                throw new Error("No compiler for '" + src + "'.");
            }
            const compiler = compilers[extension];
            module_texts[src] = text;
            return compiler(text, src);
        }

        if (import_promises[src] === undefined) {
            if (u_trace !== undefined && content === undefined) {
                u_trace("Fetching " + src);
            }
            import_promises[src] = (
                content === undefined
                ? fetch(src).then(function (response) {
                    return response.text();
                }).then(compile)
                : Promise.resolve(
                    typeof content === "string"
                    ? compile(content)
                    : content
                )
            ).then(function (ir) {
                if (ir.errors !== undefined && ir.errors.length > 0) {
                    return Promise.reject(new Error(
                        "Failed to load '"
                        + src
                        + "':\n"
                        + JSON.stringify(ir.errors, undefined, 4)
                    ));
                }

// FIXME: cyclic module dependencies cause a deadlock, but they should instead
// fail with an error.

                return Promise.all(Object.values(ir.ast.import).map(
                    function (import_src) {
                        import_src = u_map_src(import_src) ?? import_src;
                        return h_import_promise(

// We need to resolve the import specifier if it is relative.

                            import_src.startsWith(".")
                            ? (

// The URL constructor chokes when 'base' is an absolute path, rather than a
// fully qualified URL. We work around this using a dummy origin so that we can
// produce an absolute path if 'src' is an absolute path.

                                src.startsWith("/")
                                ? new URL(
                                    import_src,
                                    new URL(src, "http://_")
                                ).pathname
                                : new URL(import_src, src).href
                            )
                            : import_src
                        );
                    }
                )).then(function (imported_modules) {
                    const imports = Object.create(null);
                    Object.keys(ir.ast.import).forEach(function (name, nr) {
                        imports[name] = imported_modules[nr];
                    });
                    return h_load(ir, imports);
                });
            });
        }
        return import_promises[src];
    }

    function h_import(src, content) {

// Import and load a module, along with its dependencies. If 'content' (a text
// string or IR object) is provided, the 'src' is used only to resolve relative
// imports.

        return parseq.sequence([
            unpromise(function () {
                return h_import_promise(u_map_src(src) ?? src, content);
            }),
            requestorize(function (module) {

// If the module exports a boot behavior, make that the entrypoint.

                if (module.boot !== undefined) {
                    u_write_quad(entry_ptr, {
                        t: INSTR_T,
                        x: VM_DUP,
                        y: fixnum(0),
                        z: module.boot
                    });
                }
                return module;
            })
        ]);
    }

    function u_disasm(raw) {
        let s = print(raw);
        if (is_cap(raw)) {
            raw = u_cap_to_ptr(raw);
        }
        if (is_ptr(raw)) {
            s += ": ";
            const quad = u_read_quad(raw);
            s += print_quad(quad);
        }
        return s;
    }

    function u_pprint(raw) {
        let s = "";
        if (is_ptr(raw)) {
            let quad = u_read_quad(raw);
            let sep;
            if (quad.t === PAIR_T) {
                let p = raw;
                sep = ",";
                while (quad.t === PAIR_T) {
                    const car = u_pprint(quad.x);
                    s += (
                        car.includes(sep)
                        ? "(" + car + ")"
                        : car
                    );
                    s += sep;
                    p = quad.y;  // cdr
                    if (!is_ptr(p)) {
                        break;
                    }
                    quad = u_read_quad(p);
                }
                s += u_pprint(p);
                return s;
            }
            if (quad.t === DICT_T) {
                sep = "{";
                while (quad.t === DICT_T) {
                    s += sep;
                    s += u_pprint(quad.x);  // key
                    s += ":";
                    s += u_pprint(quad.y);  // value
                    sep = ", ";
                    quad = u_read_quad(quad.z);  // next
                }
                s += "}";
                return s;
            }
            if (quad.t === STUB_T) {
                s += "STUB[";
                s += print(quad.x);  // device
                s += ",";
                s += print(quad.y);  // target
                s += "]";
                return s;
            }
        }
        if (is_cap(raw)) {
            const ptr = u_cap_to_ptr(raw);
            const cap_quad = u_read_quad(ptr);
            if (cap_quad.t === PROXY_T) {
                s += "PROXY[";
                s += print(cap_quad.x);  // device
                s += ",";
                s += print(cap_quad.y);  // handle
                s += "]";
                return s;
            }
        }
        return print(raw);
    }

    function h_boot(instr_ptr = entry_ptr, state_ptr = UNDEF_RAW) {
        if (!is_ptr(instr_ptr)) {
            throw new Error("Not an instruction: " + u_pprint(instr_ptr));
        }

// Make a boot actor, to be sent the boot message.

        const actor = h_reserve_ram({
            t: ACTOR_T,
            x: instr_ptr,
            y: state_ptr,
            z: UNDEF_RAW
        });

// Inject the boot event (with a message holding the capabilities) to the front
// of the event queue.

        const evt = h_reserve_ram({
            t: ramptr(SPONSOR_OFS),
            x: u_ptr_to_cap(actor),
            y: boot_caps_dict.reduce(function (dict, [key_raw, value_raw]) {
                return h_reserve_ram({
                    t: DICT_T,
                    x: key_raw,
                    y: value_raw,
                    z: dict
                });
            }, NIL_RAW)
        });
        h_event_enqueue(evt);
    }

// FIXME: need a general strategy for saving and restoring device state

    function h_snapshot() {
        return {
            rom: h_rom().slice(),
            ram: h_ram().slice()
        };
    }

    function h_restore(snapshot) {
        const mem_base = u_memory();

        const rom_ofs = u_rom_ofs();
        const rom_len = snapshot.rom.byteLength;
        const rom = new Uint8Array(mem_base, rom_ofs, rom_len);
        rom.set(snapshot.rom);

        const ram_ofs = ramptr(MEMORY_OFS);
        const ram_len = snapshot.ram.byteLength;
        const ram = new Uint8Array(mem_base, ram_ofs, ram_len);
        ram.set(snapshot.ram);

        const rom_top = romptr(rom_len >> 2);
        h_set_rom_top(rom_top);  // register new top-of-ROM
    }

    function h_install(boot_key, boot_value, on_dispose, wasm_imports) {

// Install a device. This usually involves extending the boot capabilities
// dictionary, handling disposal, and providing capability functions to the
// WASM instance.

// If provided, the 'boot_key' and 'boot_value' are added to the "caps"
// dictionary provided to boot actors (created via the 'h_boot' method). Each
// entry is an array containing two values like [key, value]. Both the key and
// the value can be any raw value.

// The 'on_dispose' callback is called when the core is disposed.

// The 'wasm_imports' parameter is an object with functions to provide to the
// WASM instance. The names of these functions are hard coded into the built
// WASM, e.g. "host_clock".

        if (boot_key !== undefined && boot_value !== undefined) {
            boot_caps_dict.push([boot_key, boot_value]);
        }
        if (typeof on_dispose === "function") {
            on_dispose_callbacks.push(on_dispose);
        }
        Object.assign(wasm_caps, wasm_imports);
    }

    function h_dispose() {

// Dispose of the core by disposing of any installed devices.

        const callbacks = on_dispose_callbacks;
        on_dispose_callbacks = [];
        callbacks.forEach((on_dispose) => on_dispose());
    }

    function h_wakeup(sender, events) {
        events.map(h_event_enqueue);
        if (on_wakeup !== undefined) {
            on_wakeup(sender, events);
        }
    }

    function h_refill({memory, events, cycles}) {
        const sponsor_ptr = ramptr(SPONSOR_OFS);
        const sponsor = u_read_quad(sponsor_ptr);
        if (Number.isSafeInteger(memory)) {
            sponsor.t = fixnum(memory);
        }
        if (Number.isSafeInteger(events)) {
            sponsor.x = fixnum(events);
        }
        if (Number.isSafeInteger(cycles)) {
            sponsor.y = fixnum(cycles);
        }
        u_write_quad(sponsor_ptr, sponsor);
    }

    function h_initialize() {

// Initializes the core. This requestor should be run exactly once before the
// core is asked to do any work.

        return parseq.sequence([
            unpromise(function () {
                return WebAssembly.instantiateStreaming(fetch(wasm_url), {
                    capabilities: {
                        host_clock(...args) {
                            return wasm_caps.host_clock(...args);
                        },
                        host_random(...args) {
                            return wasm_caps.host_random(...args);
                        },
                        host_print(...args) {
                            return wasm_caps.host_print(...args);
                        },
                        host_log(...args) {
                            return wasm_caps.host_log(...args);
                        },
                        host_start_timer(...args) {
                            return wasm_caps.host_start_timer(...args);
                        },
                        host_stop_timer(...args) {
                            return wasm_caps.host_stop_timer(...args);
                        },
                        host_read(...args) {
                            return wasm_caps.host_read(...args);
                        },
                        host_write(...args) {
                            return wasm_caps.host_write(...args);
                        },
                        host_txn(...args) {
                            return wasm_caps.host_txn(...args);
                        },
                        host_audit(...args) {
                            return wasm_caps.host_audit(...args);
                        },
                        host(...args) {
                            return wasm_caps.host(...args);
                        }
                    }
                });
            }),
            requestorize(function (wasm) {
                wasm_exports = wasm.instance.exports;
                wasm.instance.exports.h_init();  // initialize WASM memory
                initial_rom_ofs = wasm.instance.exports.h_rom_buffer();
                initial_ram_ofs = wasm.instance.exports.h_ram_buffer();

// Install an anonymous plugin to handle transaction and audit information.

                Object.assign(wasm_caps, {
                    host_txn(...args) {
                        if (typeof on_txn === "function") {
                            on_txn(...args);
                        }
                    },
                    host_audit: u_audit
                });

// Install the debug device, regardless of whether debug logging is enabled.

                const dev_ptr = ramptr(DEBUG_DEV_OFS);
                const dev_cap = u_ptr_to_cap(dev_ptr);
                const dev_id = u_read_quad(dev_ptr).x;
                boot_caps_dict.push([dev_id, dev_cap]);
                Object.assign(wasm_caps, {
                    host_log(x) { // (i32) -> nil
                        if (u_debug !== undefined) {
                            const u = (x >>> 0);  // convert i32 -> u32
                            //u_debug(print(u), "->", u_pprint(u));
                            let s = print(u);
                            if (in_mem(u)) {
                                s += ": " + u_pprint(u);
                            }
                            u_debug(s);
                        }
                    }
                });

// The first quad of non-reserved ROM is the default entry point. Unless
// overwritten during load, it will trigger an E_NOT_EXE fault.

                entry_ptr = h_reserve_rom();
                return true;
            })
        ]);
    }

    return Object.freeze({

// The non-reentrant methods.

        h_boot,
        h_car,
        h_cdr,
        h_dispose,
        h_gc_color,
        h_gc_run,
        h_gc_state,
        h_import,
        h_initialize,
        h_install,
        h_load,
        h_ram,
        h_ram_top,
        h_refill,
        h_release_stub,
        h_reserve_ram,
        h_reserve_rom,
        h_reserve_stub,
        h_restore,
        h_revert,
        h_rom,
        h_rom_top,
        h_run_loop,
        h_set_rom_top,
        h_snapshot,
        h_step,
        h_wakeup,

// The reentrant methods.

        u_audit,
        u_current_continuation,
        u_debug,
        u_disasm,
        u_info,
        u_mem_pages,
        u_memory,
        u_next,
        u_nth,
        u_pprint,
        u_ram_ofs,
        u_read_quad,
        u_rom_debugs,
        u_rom_ofs,
        u_defer,
        u_module_texts,
        u_trace,
        u_warn,
        u_write_quad
    });
}

const abort_src = `
boot:                       ; _ <- {caps}
    push 123                ; reason
    end abort               ; --

.export
    boot
`;

function demo(log) {
    let core;

    function run_ufork() {
        const status = core.h_run_loop(0);
        log("IDLE:", fault_msg(fix_to_i32(status)));
    }

    core = make_core({
        wasm_url,
        log_level: ufork.LOG_DEBUG,
        on_log: log,
        on_audit(code, evidence, ep, kp) {
            log(
                "AUDIT:",
                fault_msg(fix_to_i32(code)),
                print(evidence),
                print(ep),
                print(kp)
            );
        },
        import_map: {"https://ufork.org/lib/": lib_url},
        compilers: {asm: assemble}
    });
    parseq.sequence([
        core.h_initialize(),
        parseq.parallel([
            core.h_import(asm_url),
            core.h_import("abort.asm", abort_src)
        ]),
        requestorize(function ([test_module, audit_module]) {
            const start = performance.now();
            core.h_boot(test_module.boot);
            core.h_refill({cycles: 100});
            run_ufork(); // sponsor cycle limit reached
            core.h_refill({cycles: 4096});
            run_ufork(); // #t
            core.h_boot(audit_module.boot);
            run_ufork(); // actor transaction aborted
            const duration = performance.now() - start;
            return duration.toFixed(3) + "ms";
        })
    ])(log);
}

if (import.meta.main) {
    demo(globalThis.console.log);
}

export default Object.freeze(make_core);
